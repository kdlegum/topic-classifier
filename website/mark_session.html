<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Session Details - Topic Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
  <div id="nav-container"></div>

  <main class="page-content">
    <a href="/history" class="btn-secondary back-link">Back to History</a>

    <div id="session-content">
      <div class="loading">Loading session...</div>
    </div>
  </main>

  <script type="module">
    import { renderNav } from "/static/shared/nav.js";
    import { getSession, uploadAchievedMarks } from "/static/shared/api.js";


    // Initialize navigation
    renderNav("nav-container");

    const sessionContent = document.getElementById("session-content");

    // Extract session_id from URL path: /session-view/{session_id}
    const pathParts = window.location.pathname.split("/");
    const sessionId = pathParts[pathParts.length - 1];

    if (!sessionId) {
      showError("No session ID provided");
    } else {
      loadSession(sessionId);
    }

    async function loadSession(sessionId) {
      try {
        const session = await getSession(sessionId);
        displaySession(session);
      } catch (error) {
        console.error("Error loading session:", error);
        if (error.message.includes("403") || error.message.includes("Not authorized")) {
          showError("You are not authorized to view this session.");
        } else if (error.message.includes("404") || error.message.includes("not found")) {
          showError("Session not found.");
        } else {
          showError(`Failed to load session: ${error.message}`);
        }
      }
    }

    function showError(message) {
      sessionContent.innerHTML = `
        <div class="error-state">
          <p>${message}</p>
          <p><a href="/history">Return to My Sessions</a></p>
        </div>
      `;
    }

    function displaySession(session) {
      const date = new Date(session.created_at).toLocaleDateString("en-GB", {
        day: "numeric",
        month: "long",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      });

      // Build title from qualification, subject, exam board
      const titleParts = [session.qualification, session.subject_name].filter(Boolean);
      const title = titleParts.length > 0 ? titleParts.join(" ") : session.subject;

      let html = `
        <div class="session-header">
          <h2>${title}</h2>
          <p class="session-meta">${session.exam_board} - ${date}</p>
        </div>
      `;

      session.questions.forEach((question) => {
        const marks_available = question.marks_available === null
          ? "Marks Not found"
          : `(${question.marks_available})`;

        html += `
          <div class="question-block">
            <h3>Question ${question.question_number}:</h3>
            <p>${question.question_text}</p>
            <p class="total_marks">${marks_available}</p>
        `;

        if (question.marks_achieved === null) {
          html += `
          <input
            type="number"
            class="marks-achieved"
            name="marks_achieved"
            placeholder="Marks achieved"
            data-question-id="${question.question_id}"/>
          `;
        } else {
          html += `
          <input
            type="number"
            class="marks-achieved"
            name="marks_achieved"
            value="${question.marks_achieved}"
            data-question-id="${question.question_id}"/>
          `;
        }

        question.predictions.forEach((pred) => {
          html += `
            <div class="prediction">
              <p>
                Rank ${pred.rank}: ${pred.strand} → ${pred.topic} →
                <span class="subtopic clickable" data-desc-id="desc-${question.question_id}-${pred.rank}">${pred.subtopic}</span>
                (Similarity score ${pred.similarity_score})
              </p>
              <div class="description" id="desc-${question.question_id}-${pred.rank}" style="display: none;">
                ${pred.description}
              </div>
            </div>
          `;
        });

        html += "</div>";
      });

      sessionContent.innerHTML = html;

      // Add click handlers for subtopic toggles
      sessionContent.querySelectorAll(".subtopic.clickable").forEach((el) => {
        el.addEventListener("click", () => {
          const descId = el.dataset.descId;
          const desc = document.getElementById(descId);
          if (desc) {
            desc.style.display = desc.style.display === "none" ? "block" : "none";
          }
        });
      });

      // Setup debounced mark saving AFTER DOM is ready
      setupMarksSaving(session.session_id);
    }

    // Track pending changes and debounce saving
    let pendingMarks = new Map();
    let saveTimeout = null;

    function setupMarksSaving(sessionId) {
      const inputs = document.querySelectorAll(".marks-achieved");

      inputs.forEach(input => {
        input.addEventListener("input", () => {
          const questionId = parseInt(input.dataset.questionId, 10);
          const value = input.value.trim();

          if (value === "") {
            pendingMarks.delete(questionId);
            return;
          }

          const marks = parseInt(value, 10);
          if (Number.isNaN(marks)) return;

          pendingMarks.set(questionId, marks);

          // Show saving indicator
          showSavingIndicator();

          // Debounce save
          clearTimeout(saveTimeout);
          saveTimeout = setTimeout(() => saveChanges(sessionId), 600);
        });
      });
    }

    async function saveChanges(sessionId) {
      if (pendingMarks.size === 0) {
        hideSavingIndicator();
        return;
      }

      const marksObjectList = Array.from(pendingMarks.entries()).map(
        ([question_id, marks_achieved]) => ({
          question_id,
          marks_achieved
        })
      );

      // Clear buffer optimistically
      pendingMarks.clear();

      try {
        await uploadAchievedMarks(sessionId, marksObjectList);
        showSavedIndicator();
      } catch (error) {
        console.error("Failed to save marks:", error);
        showSaveErrorIndicator();
      }
    }

    function showSavingIndicator() {
      let indicator = document.getElementById("save-indicator");
      if (!indicator) {
        indicator = document.createElement("span");
        indicator.id = "save-indicator";
        indicator.className = "save-indicator";
        const navUser = document.querySelector(".nav-user");
        if (navUser) {
          navUser.insertBefore(indicator, navUser.firstChild);
        }
      }
      indicator.textContent = "Saving...";
      indicator.className = "save-indicator saving";
    }

    function showSavedIndicator() {
      const indicator = document.getElementById("save-indicator");
      if (indicator) {
        indicator.textContent = "Saved";
        indicator.className = "save-indicator saved";
        setTimeout(() => {
          indicator.style.opacity = "0";
          setTimeout(() => indicator.remove(), 300);
        }, 1500);
      }
    }

    function showSaveErrorIndicator() {
      const indicator = document.getElementById("save-indicator");
      if (indicator) {
        indicator.textContent = "Save failed";
        indicator.className = "save-indicator error";
      }
    }

    function hideSavingIndicator() {
      const indicator = document.getElementById("save-indicator");
      if (indicator) {
        indicator.remove();
      }
    }
  </script>
</body>
</html>
