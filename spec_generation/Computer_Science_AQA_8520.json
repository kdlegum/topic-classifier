{
  "Qualification": "GCSE",
  "Subject": "Computer Science",
  "Exam Board": "AQA",
  "Specification": "8520",
  "has_math": true,
  "optional_modules": false,
  "Topics": [
    {
      "Topic_id": 1,
      "Specification_section": "3.1",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Fundamentals of algorithms",
      "Sub_topics": [
        {
          "subtopic_id": "1a",
          "Specification_section_sub": "3.1.1",
          "Sub_topic_name": "Algorithms, decomposition and abstraction",
          "description": "Understand and explain the term algorithm (a sequence of steps that can be followed to complete a task). Know that a computer program is an implementation of an algorithm, and that an algorithm is not itself a computer program. Understand and explain decomposition (breaking a problem into sub-problems so each sub-problem accomplishes an identifiable task, which may itself be further subdivided). Understand and explain abstraction (removing unnecessary detail from a problem).",
          "tier": null
        },
        {
          "subtopic_id": "1b",
          "Specification_section_sub": "3.1.1",
          "Sub_topic_name": "Representing algorithms (pseudo-code and flowcharts)",
          "description": "Use a systematic approach to problem solving and algorithm creation, representing algorithms using pseudo-code and flowcharts. Examined pseudo-code will use the AQA standard pseudo-code; when writing their own pseudo-code, students may use any clear, unambiguous style (not necessarily AQA pseudo-code).",
          "tier": null
        },
        {
          "subtopic_id": "1c",
          "Specification_section_sub": "3.1.1",
          "Sub_topic_name": "Inputs, processing and outputs (IPO)",
          "description": "Explain simple algorithms in terms of their inputs, processing and outputs. Be able to identify where inputs, processing and outputs occur within an algorithm.",
          "tier": null
        },
        {
          "subtopic_id": "1d",
          "Specification_section_sub": "3.1.1",
          "Sub_topic_name": "Tracing and purpose of algorithms",
          "description": "Determine the purpose of simple algorithms. Use trace tables and visual inspection to determine how simple algorithms work and what their purpose is.",
          "tier": null
        },
        {
          "subtopic_id": "1e",
          "Specification_section_sub": "3.1.2",
          "Sub_topic_name": "Algorithm efficiency (time)",
          "description": "Understand that more than one algorithm can solve the same problem. Compare the efficiency of algorithms and explain why some are more efficient than others for the same problem. Formal efficiency analysis (eg Big-O) is not required; exam questions will only refer to time efficiency.",
          "tier": null
        },
        {
          "subtopic_id": "1f",
          "Specification_section_sub": "3.1.3",
          "Sub_topic_name": "Linear search",
          "description": "Understand and explain how the linear search algorithm works, including the mechanics of checking each item in turn until the target is found or the data ends.",
          "tier": null
        },
        {
          "subtopic_id": "1g",
          "Specification_section_sub": "3.1.3",
          "Sub_topic_name": "Binary search",
          "description": "Understand and explain how the binary search algorithm works, including the mechanics of repeatedly halving the search range on sorted data until the target is found or the range is empty.",
          "tier": null
        },
        {
          "subtopic_id": "1h",
          "Specification_section_sub": "3.1.3",
          "Sub_topic_name": "Compare linear vs binary search",
          "description": "Compare and contrast linear and binary search algorithms, including advantages and disadvantages (eg data must be sorted for binary search; linear search works on unsorted data; typical time efficiency differences).",
          "tier": null
        },
        {
          "subtopic_id": "1i",
          "Specification_section_sub": "3.1.4",
          "Sub_topic_name": "Merge sort",
          "description": "Understand and explain how the merge sort algorithm works, including the mechanics of dividing the list into smaller sublists, sorting/merging them back together, and the use of merging two sorted lists.",
          "tier": null
        },
        {
          "subtopic_id": "1j",
          "Specification_section_sub": "3.1.4",
          "Sub_topic_name": "Bubble sort",
          "description": "Understand and explain how the bubble sort algorithm works, including the mechanics of repeated passes through data, comparing adjacent items and swapping them until sorted.",
          "tier": null
        },
        {
          "subtopic_id": "1k",
          "Specification_section_sub": "3.1.4",
          "Sub_topic_name": "Compare merge vs bubble sort",
          "description": "Compare and contrast merge sort and bubble sort, including advantages and disadvantages (eg relative time efficiency, typical use cases, and how they operate).",
          "tier": null
        }
      ]
    },
    {
      "Topic_id": 2,
      "Specification_section": "3.2",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Programming",
      "Sub_topics": [
        {
          "subtopic_id": "2a",
          "Specification_section_sub": "3.2.1",
          "Sub_topic_name": "Data types",
          "description": "Understand the concept of a data type. Understand and use appropriately: integer, real, Boolean, character, string. Recognise that programming languages may use different names (eg real may be float), but exams will use the general names listed.",
          "tier": null
        },
        {
          "subtopic_id": "2b",
          "Specification_section_sub": "3.2.2",
          "Sub_topic_name": "Core programming constructs and statements",
          "description": "Use, understand and know how to combine statement types in programs: variable declaration, constant declaration, assignment, iteration, selection, and subroutines (procedure/function). Understand the combining principles (sequence, iteration/repetition, selection/choice) as fundamental to imperative programming. Be able to write programs using these statement types and interpret algorithms that use them. Know why named constants and variables are used.",
          "tier": null
        },
        {
          "subtopic_id": "2c",
          "Specification_section_sub": "3.2.2",
          "Sub_topic_name": "Iteration types (definite and indefinite)",
          "description": "Use definite and indefinite iteration, including indefinite iteration with the condition(s) at the start or end of the loop structure. A theoretical understanding of conditions at either end is required even if the chosen language does not support both forms. Example forms include FOR i 1 TO 5 ... ENDFOR; WHILE NotSolved ... ENDWHILE; REPEAT ... UNTIL Solved.",
          "tier": null
        },
        {
          "subtopic_id": "2d",
          "Specification_section_sub": "3.2.2",
          "Sub_topic_name": "Nested selection and nested iteration",
          "description": "Use nested selection and nested iteration structures. Be able to interpret and construct nested control structures (eg a loop inside a loop; an IF inside an IF) as required by a problem.",
          "tier": null
        },
        {
          "subtopic_id": "2e",
          "Specification_section_sub": "3.2.2",
          "Sub_topic_name": "Identifier names and readability",
          "description": "Use meaningful identifier names (variables, constants, subroutines) and know why meaningful naming is important for clarity and maintainability.",
          "tier": null
        },
        {
          "subtopic_id": "2f",
          "Specification_section_sub": "3.2.3",
          "Sub_topic_name": "Arithmetic operations (including DIV and MOD)",
          "description": "Be familiar with and be able to use arithmetic operations: addition, subtraction, multiplication, real division, and integer division including remainders. Understand integer division as quotient and remainder using modular arithmetic (eg 11 DIV 2 = 5; 11 MOD 2 = 1).",
          "tier": null
        },
        {
          "subtopic_id": "2g",
          "Specification_section_sub": "3.2.4",
          "Sub_topic_name": "Relational operators",
          "description": "Be familiar with and be able to use relational operations: equal to, not equal to, less than, greater than, less than or equal to, greater than or equal to. Interpret these within algorithms/programs. Exams may use symbols =, ≠, <, >, ≤, ≥ (even if languages use different symbols).",
          "tier": null
        },
        {
          "subtopic_id": "2h",
          "Specification_section_sub": "3.2.5",
          "Sub_topic_name": "Boolean operators in conditions",
          "description": "Be familiar with and be able to use Boolean operations NOT, AND, OR, including combinations of these operators within conditions for selection and iteration structures.",
          "tier": null
        },
        {
          "subtopic_id": "2i",
          "Specification_section_sub": "3.2.6",
          "Sub_topic_name": "Data structures (concept, arrays, records)",
          "description": "Understand the concept of data structures. Use arrays (or equivalent) in designing solutions to simple problems; only one-dimensional and two-dimensional arrays are required. Use records (or equivalent) in designing solutions to simple problems.",
          "tier": null
        },
        {
          "subtopic_id": "2j",
          "Specification_section_sub": "3.2.7",
          "Sub_topic_name": "Input, output and text files",
          "description": "Obtain user input from the keyboard. Output data/information from a program to the computer display. Read from and write to a text file (basic file handling).",
          "tier": null
        },
        {
          "subtopic_id": "2k",
          "Specification_section_sub": "3.2.8",
          "Sub_topic_name": "String handling and conversions",
          "description": "Understand and be able to use string operations: length, position, substring, concatenation, convert character to character code, convert character code to character. Perform string conversion operations: string→integer, string→real, integer→string, real→string.",
          "tier": null
        },
        {
          "subtopic_id": "2l",
          "Specification_section_sub": "3.2.9",
          "Sub_topic_name": "Random number generation",
          "description": "Be able to use random number generation within programs. Understanding how pseudo-random numbers are generated is not required.",
          "tier": null
        },
        {
          "subtopic_id": "2m",
          "Specification_section_sub": "3.2.10",
          "Sub_topic_name": "Subroutines: purpose, parameters, return values, local variables",
          "description": "Understand the concept of subroutines: a named ‘out of line’ block of code that can be called by name. Explain advantages of subroutines. Describe and use parameters to pass data into subroutines (including more than one parameter). Use functions/subroutines that return values to the caller and describe passing data out using return values. Know that subroutines may declare local variables which usually only exist while executing and are only accessible within the subroutine; use local variables and explain why this is good practice.",
          "tier": null
        },
        {
          "subtopic_id": "2n",
          "Specification_section_sub": "3.2.11",
          "Sub_topic_name": "Structured programming",
          "description": "Describe the structured approach to programming, including modularised programming, clear and well-documented interfaces (local variables, parameters) and return values. Explain advantages of structured programming. Note: although ‘arguments’/‘parameters’ may be used elsewhere, examinable material uses ‘parameter’ for both.",
          "tier": null
        },
        {
          "subtopic_id": "2o",
          "Specification_section_sub": "3.2.12",
          "Sub_topic_name": "Robust and secure programming (validation, authentication, testing)",
          "description": "Write simple data validation routines to check user-entered data (eg minimum string length, empty string, range checks such as between 1 and 10). Write simple authentication routines using username and password; only plain text usernames/passwords are required (no encryption required). Select suitable test data that covers normal (typical), boundary (extreme) and erroneous data, and justify the choice of test data.",
          "tier": null
        },
        {
          "subtopic_id": "2p",
          "Specification_section_sub": "3.2.13",
          "Sub_topic_name": "Low-level vs high-level languages; translators",
          "description": "Know different levels of programming language: low-level and high-level; explain main differences and why most programs are written in high-level languages. Know machine code and assembly are low-level; explain differences between machine code and assembly. Understand processors execute machine code and each processor/family has its own instruction set; machine code is expressed in binary and is processor-specific. Understand assembly is often used for embedded systems and controlling specific hardware components and has a 1:1 correspondence with machine code. Understand all high-level/assembly must be translated into machine code. Understand advantages/disadvantages of low-level vs high-level programming. Know three common program translators: interpreter, compiler, assembler; explain differences and when each is appropriate.",
          "tier": null
        }
      ]
    },
    {
      "Topic_id": 3,
      "Specification_section": "3.3",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Fundamentals of data representation",
      "Sub_topics": [
        {
          "subtopic_id": "3a",
          "Specification_section_sub": "3.3.1",
          "Sub_topic_name": "Number bases and binary as universal representation",
          "description": "Understand number bases: decimal (base 10), binary (base 2), hexadecimal (base 16). Understand computers use binary to represent all data and instructions, and that the same bit pattern can represent different data types (eg text, image, sound, integer). Explain why hexadecimal is often used in computer science.",
          "tier": null
        },
        {
          "subtopic_id": "3b",
          "Specification_section_sub": "3.3.2",
          "Sub_topic_name": "Convert between binary, decimal and hexadecimal (0–255)",
          "description": "Understand how binary represents whole numbers; be able to represent decimal values 0–255 in binary. Understand how hexadecimal represents whole numbers; be able to represent decimal values 0–255 in hexadecimal. Convert both directions between: binary↔decimal, binary↔hexadecimal, decimal↔hexadecimal. Maximum equivalences used: decimal 255, binary 1111 1111, hexadecimal FF.",
          "tier": null
        },
        {
          "subtopic_id": "3c",
          "Specification_section_sub": "3.3.3",
          "Sub_topic_name": "Units of information and decimal prefixes",
          "description": "Know a bit is the fundamental unit of information (0 or 1) and a byte is a group of 8 bits; b denotes bit and B denotes byte. Know quantities of bytes use decimal prefixes and corresponding values: kilo (1 kB = 1,000 bytes), mega (1 MB = 1,000 kB), giga (1 GB = 1,000 MB), tera (1 TB = 1,000 GB). Understand historical ambiguity with powers of 2; SI prefixes here are powers of 10 (students do not need kibi/mebi terminology).",
          "tier": null
        },
        {
          "subtopic_id": "3d",
          "Specification_section_sub": "3.3.4",
          "Sub_topic_name": "Binary addition and logical shifts",
          "description": "Add up to three binary numbers using up to 8 bits; answers up to 8 bits and no carry beyond 8 bits. Apply a logical binary shift to a binary number (up to 8 bits). Describe situations where binary shifts are used, such as multiplication/division by powers of 2. Fractional representations are not required.",
          "tier": null
        },
        {
          "subtopic_id": "3e",
          "Specification_section_sub": "3.3.5",
          "Sub_topic_name": "Character encoding: ASCII and Unicode",
          "description": "Understand what a character set is. Describe 7-bit ASCII and Unicode. Use a given encoding table to convert characters→character codes and character codes→characters. Understand character codes are commonly grouped and sequential (eg ASCII 'A'=65, 'B'=66 etc; similar patterns for lowercase and digits). Describe purpose of Unicode and advantages over ASCII, including representing multiple alphabets and special symbols; know Unicode uses the same codes as ASCII up to 127. Detailed knowledge of UTF-8/UTF-16 not required.",
          "tier": null
        },
        {
          "subtopic_id": "3f",
          "Specification_section_sub": "3.3.6",
          "Sub_topic_name": "Bitmap images: pixels, colour depth, file size, and binary ↔ B/W images",
          "description": "Understand what a pixel (picture element) is and how pixels relate to images and display (screen divided into rows/columns of pixels). For bitmaps, describe size in pixels (width × height) and colour depth (bits per pixel). Explain how a bitmap represents an image using pixels and colour depth. Describe how number of pixels and colour depth affect file size; calculate bitmap file sizes using: Size(bits)=W×H×D and Size(bytes)=(W×H×D)/8 where W=width (pixels), H=height (pixels), D=colour depth (bits). Convert given binary data into a black-and-white image (draw pixels) and convert a black-and-white bitmap image into binary data.",
          "tier": null
        },
        {
          "subtopic_id": "3g",
          "Specification_section_sub": "3.3.7",
          "Sub_topic_name": "Digital sound: sampling rate, resolution, file size",
          "description": "Understand sound is analogue and must be converted to digital for storage/processing. Understand sampling: sound waves are sampled; a sample measures amplitude at a point in time. Describe digital sound in terms of sampling rate (samples per second, in hertz; 1 Hz = 1 sample/second) and sample resolution (bits per sample). Calculate sound file sizes using: File size(bits)=rate×res×secs where rate=sampling rate, res=sample resolution, secs=duration in seconds.",
          "tier": null
        },
        {
          "subtopic_id": "3h",
          "Specification_section_sub": "3.3.8",
          "Sub_topic_name": "Data compression (Huffman and RLE)",
          "description": "Explain what data compression is and why data may be compressed; understand there are different compression methods. Explain how Huffman coding compresses data; interpret Huffman trees and determine codes for nodes; calculate bits required to store compressed data using a given Huffman code; calculate bits to store uncompressed data in ASCII; calculate bits saved by compression. Explain run length encoding (RLE) compression using frequency/data pairs to reduce stored data. Represent data in RLE frequency/data pairs, eg row 0000011100000011 becomes 5 0 3 1 6 0 2 1.",
          "tier": null
        }
      ]
    },
    {
      "Topic_id": 4,
      "Specification_section": "3.4",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Computer systems",
      "Sub_topics": [
        {
          "subtopic_id": "4a",
          "Specification_section_sub": "3.4.1",
          "Sub_topic_name": "Hardware and software",
          "description": "Define hardware and software and understand the relationship between them.",
          "tier": null
        },
        {
          "subtopic_id": "4b",
          "Specification_section_sub": "3.4.2",
          "Sub_topic_name": "Boolean logic: truth tables and logic circuits",
          "description": "Construct truth tables for logic gates NOT, AND, OR. Construct truth tables for simple logic circuits and interpret results. Create, modify and interpret simple logic circuit diagrams using standard symbols; circuits/truth tables may contain up to three inputs. Only AND, OR and NOT gates are required; NAND, NOR and XOR are not required.",
          "tier": null
        },
        {
          "subtopic_id": "4c",
          "Specification_section_sub": "3.4.3",
          "Sub_topic_name": "System and application software; operating systems and utilities",
          "description": "Explain what is meant by system software and application software and give examples of each. Understand the need for and functions of operating systems (OS) and utility programs. Understand the OS manages processor(s), memory, I/O devices, applications and security.",
          "tier": null
        },
        {
          "subtopic_id": "4d",
          "Specification_section_sub": "3.4.4",
          "Sub_topic_name": "Von Neumann architecture and CPU components",
          "description": "Explain the Von Neumann architecture. Explain the role and operation of main memory and major CPU components: arithmetic logic unit (ALU), control unit, clock, bus. Understand a bus as a collection of wires transmitting data between components. Main memory is any memory directly accessible by the CPU except cache and registers.",
          "tier": null
        },
        {
          "subtopic_id": "4e",
          "Specification_section_sub": "3.4.4",
          "Sub_topic_name": "CPU performance factors",
          "description": "Explain the effect on CPU performance of: clock speed, number of processor cores, cache size, cache type.",
          "tier": null
        },
        {
          "subtopic_id": "4f",
          "Specification_section_sub": "3.4.4",
          "Sub_topic_name": "Fetch-Execute cycle",
          "description": "Understand and explain the Fetch-Execute cycle: CPU continuously reads instructions stored in main memory and executes them. Stages: fetch (next instruction fetched from main memory), decode (instruction decoded), execute (instruction carried out, may include reading/writing to main memory).",
          "tier": null
        },
        {
          "subtopic_id": "4g",
          "Specification_section_sub": "3.4.4",
          "Sub_topic_name": "Memory and storage: RAM/ROM, main vs secondary",
          "description": "Understand differences between main memory and secondary storage. Understand differences between RAM and ROM, including volatile vs non-volatile. Understand why secondary storage is required. Secondary storage is any non-volatile storage mechanism external to the CPU.",
          "tier": null
        },
        {
          "subtopic_id": "4h",
          "Specification_section_sub": "3.4.4",
          "Sub_topic_name": "Secondary storage types and cloud storage",
          "description": "Be aware of types of secondary storage: solid state, optical, magnetic. Explain how each operates and discuss advantages/disadvantages of each. Know SSDs use electrical circuits to persistently store data (no need for NAND detail). Explain 'cloud storage' as storage at a remote location using magnetic and increasingly solid state storage. Explain advantages and disadvantages of cloud storage compared with local storage.",
          "tier": null
        },
        {
          "subtopic_id": "4i",
          "Specification_section_sub": "3.4.4",
          "Sub_topic_name": "Embedded systems",
          "description": "Understand 'embedded system' and explain how embedded differs from non-embedded systems. Give examples of embedded and non-embedded systems.",
          "tier": null
        }
      ]
    },
    {
      "Topic_id": 5,
      "Specification_section": "3.5",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Fundamentals of computer networks",
      "Sub_topics": [
        {
          "subtopic_id": "5a",
          "Specification_section_sub": "3.5",
          "Sub_topic_name": "What networks are; benefits and risks",
          "description": "Define a computer network. Discuss benefits and risks of computer networks (eg resource sharing, communication, security/privacy risks, dependency, management).",
          "tier": null
        },
        {
          "subtopic_id": "5b",
          "Specification_section_sub": "3.5",
          "Sub_topic_name": "Network types: PAN, LAN, WAN",
          "description": "Describe main types of network: PAN, LAN, WAN. PAN: only Bluetooth needs to be considered. LAN: typically small geographical areas and often owned/controlled/managed by a single person/organisation. WAN: covers wide geographic areas; Internet as the biggest example; often under collective or distributed ownership.",
          "tier": null
        },
        {
          "subtopic_id": "5c",
          "Specification_section_sub": "3.5",
          "Sub_topic_name": "Wired vs wireless networks; media choices",
          "description": "Understand networks can be wired or wireless. Discuss benefits and risks of wireless compared with wired networks. Know wired networks can use different cable types such as fibre and copper and when each would be appropriate (eg speed/bandwidth, distance, interference, cost).",
          "tier": null
        },
        {
          "subtopic_id": "5d",
          "Specification_section_sub": "3.5",
          "Sub_topic_name": "Network topologies: star and bus",
          "description": "Explain common network topologies: star and bus. Draw topology diagrams, explain differences, and select the most appropriate topology for a given scenario (including typical strengths/weaknesses such as single points of failure, ease of adding nodes, cable requirements).",
          "tier": null
        },
        {
          "subtopic_id": "5e",
          "Specification_section_sub": "3.5",
          "Sub_topic_name": "Network protocols and what they are for",
          "description": "Define 'network protocol'. Explain purpose and use of common protocols: Ethernet, Wi‑Fi, TCP, UDP, IP, HTTP, HTTPS, FTP, and email protocols SMTP and IMAP. Know what each is used for (eg HTTPS is encrypted HTTP for more secure web transactions). Understand Ethernet and Wi‑Fi are families of related protocols (not a single protocol); Wi‑Fi is a trademark and the generic term is WLAN.",
          "tier": null
        },
        {
          "subtopic_id": "5f",
          "Specification_section_sub": "3.5",
          "Sub_topic_name": "Network security methods",
          "description": "Understand the need for and importance of network security. Explain methods: authentication, encryption, firewall, MAC address filtering. Explain with examples what each method is and when used, and how methods can be combined for greater security. Understand MAC address filtering allows/blocks devices based on the physical MAC address embedded in the network adapter.",
          "tier": null
        },
        {
          "subtopic_id": "5g",
          "Specification_section_sub": "3.5",
          "Sub_topic_name": "4-layer TCP/IP model and protocol layers",
          "description": "Describe the 4-layer TCP/IP model: application, transport, network, data link. Know which protocols operate at which layers: HTTP/HTTPS/SMTP/IMAP/FTP at application; TCP/UDP at transport; IP at network. Name layers and describe main functions: application (network apps like browsers/email), transport (sets up host-to-host comms; agree settings such as ‘language’ and packet sizes), network (addresses/packages data; routes packets), data link (network hardware like NIC and OS device drivers). Be aware alternative names exist (network layer sometimes 'internet layer'; data link sometimes 'network interface layer') but students are not required to know these alternatives.",
          "tier": null
        }
      ]
    },
    {
      "Topic_id": 6,
      "Specification_section": "3.6",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Fundamentals of cyber security",
      "Sub_topics": [
        {
          "subtopic_id": "6a",
          "Specification_section_sub": "3.6",
          "Sub_topic_name": "Cyber security definition and purposes",
          "description": "Define cyber security and describe main purposes. Understand cyber security consists of processes, practices and technologies designed to protect networks, computers, programs and data from attack, damage or unauthorised access.",
          "tier": null
        },
        {
          "subtopic_id": "6b",
          "Specification_section_sub": "3.6.1",
          "Sub_topic_name": "Cyber security threats (overview list)",
          "description": "Understand and explain cyber security threats including: social engineering techniques, malicious code, weak and default passwords, misconfigured access rights, removable media, and unpatched and/or outdated software.",
          "tier": null
        },
        {
          "subtopic_id": "6c",
          "Specification_section_sub": "3.6.1",
          "Sub_topic_name": "Penetration testing (white-box vs black-box)",
          "description": "Explain what penetration testing is and what it is used for (attempting to gain access to resources without knowledge of usernames/passwords and other normal means). Understand aims of white-box penetration testing (simulate malicious insider with knowledge and possibly basic credentials). Understand aims of black-box penetration testing (simulate external hacking/cyber warfare attack).",
          "tier": null
        },
        {
          "subtopic_id": "6d",
          "Specification_section_sub": "3.6.1.1",
          "Sub_topic_name": "Social engineering: types and protection",
          "description": "Define social engineering (manipulating people so they give up confidential information). Describe what it is and how to protect against it. Explain forms: blagging/pretexting (invented scenario to elicit information/actions), phishing (fraudulently obtaining private information often via email/SMS), pharming (redirecting website traffic to a fake site), shouldering/shoulder surfing (observing private information over someone’s shoulder, eg ATM PIN).",
          "tier": null
        },
        {
          "subtopic_id": "6e",
          "Specification_section_sub": "3.6.1.2",
          "Sub_topic_name": "Malware: definition, types and protection",
          "description": "Define malware (umbrella term for hostile/intrusive software). Describe what malware is and how to protect against it. Describe forms: computer virus, trojan, spyware, adware.",
          "tier": null
        },
        {
          "subtopic_id": "6f",
          "Specification_section_sub": "3.6.2",
          "Sub_topic_name": "Security measures to detect/prevent threats",
          "description": "Understand and explain security measures: biometric measures (particularly for mobile devices), password systems, CAPTCHA (or similar), using email confirmations to confirm a user’s identity, and automatic software updates.",
          "tier": null
        }
      ]
    },
    {
      "Topic_id": 7,
      "Specification_section": "3.7",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Ethical, legal and environmental impacts of digital technology on wider society, including issues of privacy",
      "Sub_topics": [
        {
          "subtopic_id": "7a",
          "Specification_section_sub": "3.7",
          "Sub_topic_name": "Impacts, risks, and privacy trade-offs (exam issue areas)",
          "description": "Explain current ethical, legal and environmental impacts and risks of digital technology on society; where data privacy issues arise, they must be considered. Exam questions may be drawn from: cyber security, mobile technologies, wireless networking, cloud storage, theft of computer code, issues around copyright of algorithms, cracking, hacking, wearable technologies, computer-based implants. Understand and explain general principles rather than detailed knowledge of specific cases. Understand privacy tensions: citizens value privacy and may dislike extensive government/security-service access; governments/security services argue access to private data may be needed to keep citizens safe from terrorism and other attacks.",
          "tier": null
        }
      ]
    },
    {
      "Topic_id": 8,
      "Specification_section": "3.8",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Aspects of software development",
      "Sub_topics": [
        {
          "subtopic_id": "8a",
          "Specification_section_sub": "3.8",
          "Sub_topic_name": "Design (NEA skill: planning before coding)",
          "description": "Before constructing a solution, be aware the solution should be designed: plan data structures for the data model, design algorithms, design an appropriate modular structure, and design the user interface as appropriate. Students need experience structuring programs into modular parts with clear documented interfaces to design suitable modular structures. Students need experience including authentication and data validation systems within programs.",
          "tier": null
        },
        {
          "subtopic_id": "8b",
          "Specification_section_sub": "3.8",
          "Sub_topic_name": "Implementation (NEA skill: building the model/code)",
          "description": "Be aware that models and algorithms must be implemented as data structures and code (instructions) that a computer can understand. Students need practice writing, debugging and testing programs to be able to articulate how programs work and argue using logical reasoning for correctness in solving specified problems.",
          "tier": null
        },
        {
          "subtopic_id": "8c",
          "Specification_section_sub": "3.8",
          "Sub_topic_name": "Testing (NEA skill: normal/boundary/erroneous)",
          "description": "Be aware implementation must be tested for errors using selected test data covering normal (typical), boundary (extreme) and erroneous data. Students need practical experience designing and applying these types of test data and understanding why testing is needed.",
          "tier": null
        },
        {
          "subtopic_id": "8d",
          "Specification_section_sub": "3.8",
          "Sub_topic_name": "Evaluation and refining (NEA skill: improve solution)",
          "description": "Be aware code created during implementation often requires refining as a result of testing. Be aware of importance of assessing how well the solution meets the problem requirements and how it could be improved if revisited. Students need experience refining programs in response to tests, assessing how well solutions meet requirements, and explaining improvements for a revisit.",
          "tier": null
        }
      ]
    },
    {
      "Topic_id": 9,
      "Specification_section": "3.9",
      "Strand": "GCSE Computer Science (8520)",
      "Topic_name": "Non-exam assessment",
      "Sub_topics": [
        {
          "subtopic_id": "9a",
          "Specification_section_sub": "3.9.1.1",
          "Sub_topic_name": "Purpose of NEA",
          "description": "Understand the purpose of NEA: develop practical skills in a problem-solving context by coding a solution to a given problem; it is both a learning experience and assessment over time, extending programming skills and understanding of practical real-world applications.",
          "tier": null
        },
        {
          "subtopic_id": "9b",
          "Specification_section_sub": "3.9.2.1",
          "Sub_topic_name": "Setting the NEA task (AQA-provided)",
          "description": "Understand that AQA sets the NEA task; it becomes available to centres in September of the final academic year of the course, changes each cohort, and teachers must ensure the correct task is used.",
          "tier": null
        },
        {
          "subtopic_id": "9c",
          "Specification_section_sub": "3.9.2.2",
          "Sub_topic_name": "Taking the NEA task (20 hours; independent; language)",
          "description": "The NEA comprises a single project undertaken over a total of 20 hours. Students must work independently and produce a unique piece of work. Students must program in one of the high-level languages permitted for that year’s NEA. Outputs: (1) program designed, written, tested and refined by the student, and (2) written report (hard copy or electronic, eg saved to CD).",
          "tier": null
        },
        {
          "subtopic_id": "9d",
          "Specification_section_sub": "3.9.2.3",
          "Sub_topic_name": "Authentication and supervision rules",
          "description": "Teachers must be confident evidence is the student’s own work, completed in 20 hours under supervised conditions, and authenticate it. Students must not take the NEA task home and must not take work on the NEA home to complete; all submitted work must be completed under supervised conditions.",
          "tier": null
        },
        {
          "subtopic_id": "9e",
          "Specification_section_sub": "3.9.3",
          "Sub_topic_name": "Marking process (redrafts; final submission)",
          "description": "Students may redraft before final submission. After submission for final assessment, no further amendments can be made. Teachers mark using the specification’s marking criteria; further NEA marking support is available via AQA resources.",
          "tier": null
        },
        {
          "subtopic_id": "9f",
          "Specification_section_sub": "3.9.3.2",
          "Sub_topic_name": "Level of response marking (how levels/marks are decided)",
          "description": "Understand level-of-response marking: Step 1 determine a level by matching overall qualities to descriptors using a best-fit approach; do not over-penalise minor weaknesses if overall performance meets the level; if mostly level 3 with some level 4 content, award level 3 near top. Step 2 determine a mark within level using descriptor guidance and standardisation exemplars; compare with lead examiner examples. Indicative content is not exhaustive; credit other valid points. Work with nothing relevant receives 0 marks.",
          "tier": null
        },
        {
          "subtopic_id": "9g",
          "Specification_section_sub": "3.9.4",
          "Sub_topic_name": "NEA assessment sections and mark totals",
          "description": "Know NEA is assessed in five sections with maximum marks: (1) Designing the solution (9), (2) Creating the solution (30), (3) Testing the solution (21), (4) Potential enhancements and refinements (10), (5) Overall quality of the report (10); total 80 marks.",
          "tier": null
        },
        {
          "subtopic_id": "9h",
          "Specification_section_sub": "3.9.4.1",
          "Sub_topic_name": "Designing the solution (mark criteria focus)",
          "description": "Design section: communicate design clearly enough for a third party to understand solution structure. Acceptable evidence: prose and/or diagrams (eg flowcharts), algorithm descriptions, data structures, text file/database structures, pseudo-code; UI design may be evidenced by screenshots. Level descriptors: Level 3 (7–9) comprehensive design suitable for effective implementation of complete/almost complete solution; good understanding of variables, data types/structures and processing; explains all/almost all main blocks including data validation where appropriate; design choices justified with reference to user requirements. Level 2 (4–6) detailed design for most key aspects; largely effective variable design but limited use of data types/structures; explains most main blocks including calculations where appropriate; choices described. Level 1 (1–3) minimal/incomplete design; minimal descriptions making structure unclear without code; choices stated. Level 0: none.",
          "tier": null
        },
        {
          "subtopic_id": "9i",
          "Specification_section_sub": "3.9.4.2",
          "Sub_topic_name": "Creating the solution: completeness (15)",
          "description": "Creating section—completeness of solution (15): students present complete code listing, annotated via comments or other annotation. To gain marks in a level, code and annotations must show requirements of that level. Levels: 5 (13–15) meets all/almost all requirements; top includes well-implemented robustness and structured programming. 4 (10–12) meets most requirements; uses structured programming effectively; top includes some robustness. 3 (7–9) meets some requirements; top includes some structured programming and some validation. 2 (4–6) meets a few requirements; top includes minimal structured programming. 1 (1–3) tackles a few aspects; may not work as intended. 0 none.",
          "tier": null
        },
        {
          "subtopic_id": "9j",
          "Specification_section_sub": "3.9.4.2",
          "Sub_topic_name": "Creating the solution: programming techniques (15)",
          "description": "Creating section—programming techniques used (15): assessed holistically (not a checklist). Students provide annotated/self-documenting program listings; may include explanations of difficult sections and clear division into labelled sections for navigation. Best-fit approach: absence of a technique may be acceptable if not appropriate. Level indicators include use of meaningful identifiers, indentation, consistent style, constants, validation, modularisation, local variables/minimal globals, subroutines with interfaces, and exception handling as appropriate. Level 5 (13–15) proficient; successful solution using exception handling, validation, subroutine interfaces as appropriate; effectively used data structures; structured for maintenance; outstanding features include cohesive modular subroutines, good exception handling, self-documenting code, appropriate validation/constants, local variables, minimal globals, consistent style/indentation and effective annotations. Level 4 (10–12) proficient; largely successful; modularisation plus exception handling and/or validation as appropriate; excellent features similar but less complete. Level 3 (7–9) solves most of problem; modularisation as appropriate; validation evident and appropriate; good use of locals/minimal globals/constants/style/indentation/annotation. Level 2 (4–6) multiple techniques; some understanding via annotation; meaningful variables; basic constants/style/indentation/annotation. Level 1 (1–3) at least one of input/process/output; minimal comments; meaningful variables for parts; minimal naming/indentation/annotation. Level 0 none.",
          "tier": null
        },
        {
          "subtopic_id": "9k",
          "Specification_section_sub": "3.9.4.3",
          "Sub_topic_name": "Testing the solution: test planning (9)",
          "description": "Testing is about 'Does the solution work?'. Students plan tests to show different sections/elements work as intended; tests may be produced during or after coding. Only carefully selected representative samples required. Use normal (typical), boundary (extreme) and erroneous data as appropriate. Test plan should include: test performed, purpose, test data, expected outcome. Test planning levels: Level 3 (7–9) thorough representative range demonstrating robustness and requirements achieved; includes normal/boundary/erroneous; detailed expected outcomes; clear and unambiguous. Level 2 (4–6) representative but falls short of demonstrating all requirements; includes some different types; expected outcomes listed; clear. Level 1 (1–3) small number; some inappropriate; some data/outcomes; may be unclear. Level 0 none.",
          "tier": null
        },
        {
          "subtopic_id": "9l",
          "Specification_section_sub": "3.9.4.3",
          "Sub_topic_name": "Testing the solution: evidence (12) and refinement after failures",
          "description": "Testing evidence: present clear evidence in structured form (eg tables) using carefully selected representative samples; include actual outcome and sampled evidence (eg screenshots before/after) to limit volume. Explain reasons for tests alongside evidence. If a test fails or highlights an issue, refine solution to eliminate the failure/issue and repeat test to show fix succeeded. Evidence levels: Level 4 (10–12) clear representative samples show thorough testing; explanation shows robustness of complete/nearly complete solution and that requirements achieved. Level 3 (7–9) extensive testing but evidence does not clearly show all core requirements achieved (key aspects not tested or evidence unclear); explanation shows partial robustness. Level 2 (4–6) range of tests but well short of demonstrating requirements and robustness; explained. Level 1 (1–3) small number; shows some parts work; evidence not entirely clear. Level 0 none.",
          "tier": null
        },
        {
          "subtopic_id": "9m",
          "Specification_section_sub": "3.9.4.4",
          "Sub_topic_name": "Potential enhancements and refinements (evaluation)",
          "description": "Evaluation asks: how well does the solution work and how could it be better? Consider how well solution meets requirements and improvements if revisited. Level 5 (9–10) full consideration for all/almost all requirements; discuss efficiency of execution and robustness; discuss improvements. Level 4 (7–8) some consideration for all/almost all requirements; describe efficiency or robustness; explain improvements. Level 3 (5–6) consider most requirements and, where appropriate, requirements not met; describe improvements. Level 2 (3–4) consider some requirements but omissions; may overlook unmet requirements; state some improvements. Level 1 (1–2) superficial evaluation. Level 0 none.",
          "tier": null
        },
        {
          "subtopic_id": "9n",
          "Specification_section_sub": "3.9.4.5",
          "Sub_topic_name": "Overall quality of report (structure, relevance, terminology, cross-referencing)",
          "description": "Report should include sections: designing, creating, testing, potential enhancements/refinements, with enough evidence for marks in each. Marks reward quality: Level 5 (9–10) complete; all/almost all content relevant; wide range of technical terms used accurately; consistent structure/layout enabling easy cross-referencing between sections and code; consistency between design↔code, design↔testing, evaluation↔refinement. Level 4 (7–8) complete; most content relevant; most terms accurate; consistent structure/layout enabling cross-referencing for most sections; consistency evident across design, code, testing, evaluation/refinement. Level 3 (5–6) complete in all/almost all respects; a few technical terms accurate; some attempt at structure for limited cross-referencing; some consistency between at least three of: design, code, testing, evaluation/refinement. Level 2 (3–4) at most one section missing/incomplete; little attempt at cross-referencing; gives some idea of development; code listing consistent with other sections. Level 1 (1–2) two or more sections missing; no cross-referencing structure; unclear account of development. Level 0 none.",
          "tier": null
        }
      ]
    }
  ]
}